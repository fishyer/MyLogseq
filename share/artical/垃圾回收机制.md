---
date: 2022-04-27T02:21:37+08:00
title: 垃圾回收机制
---

# 垃圾回收机制

垃圾回收算法一般要做2件基本的事情：

（1）发现无用信息对象；

（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。　

## 1.引用计数法(Reference Counting Collector)

堆中每个对象实例都有一个引用计数。

当任何变量被赋值为这个对象的引用时，计数+1（a=b,则b引用的对象实例的计数器+1）
当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器-1

任何引用计数器为0的对象实例可以被当作垃圾收集。
缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

## 2.tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)

根搜索算法

是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image.png)

java中可作为GC Root的对象有
　　1.虚拟机栈中引用的对象（本地变量表）
　　2.方法区中静态属性引用的对象
　　3. 方法区中常量引用的对象
　　4.本地方法栈中引用的对象（Native对象）

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_1.png)

标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。

标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

## 3.copying算法

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_2.png)

该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。

它开始时把堆分成1个较大的Eden和2个较小的Survivor（Eden：Survivor=8：1），每次使用Eden和其中一块Survivor。
回收时，将Eden和Survivor中还活着的对象一次性复制到另一个Survivor中。
当Survivor空间不够用时，需要老年代进行分配担保。

## 4.compacting算法 或 标记-整理算法

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_3.png)

标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。适用于老年代。

## 5.generation算法(Generational Collector)

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_4.png)

分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。

### 新年代（Young Generation）

所有新生成的对象首先都是放在新生代的

新生代的目标就是尽可能快速的收集掉那些生命周期短的对象

新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高

### 老年代（Old Generation）

老年代中存放的都是一些生命周期较长的对象。

内存比新生代也大很多(大概比例是1:2)

老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收

### 持久代（Permanent Generation）

用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

## 方法区回收

判定一个类是否“无用的类”条件就要苛刻很多，类需要同时满足以下三个条件：

1. 该类所有实例都已经被回收，也就是说Java堆中不存在该类的任何实例

2. 加载该类的ClassLoader已经被回收

3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证方法区不会溢出。

## HotSpot虚拟机的收集器

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_5.png)

没有最好的垃圾收集器，更加没有万能的收集器，只能选择对具体应用最合适的收集器。

### 1、Serial收集器

采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。

Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器

### 2、ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本

### 3、Parallel收集器

CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel收集器的目标则是打到一个可控制的吞吐量。
吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
Parallel收集器是虚拟机运行在Server模式下的默认垃圾收集器。
如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。

### 4、Serial Old收集器

Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，给Client模式下的虚拟机使用。

### 5、Parallel Old收集器

Parallel收集器的老年代版本，使用多线程和“标记-整理”算法

### 6、CMS收集器

CMS收集器是一种以获取最短回收停顿时间为目标的老年代收集器。CMS收集器从名字就能看出是基于“标记-清除”算法实现的。

### 7、G1收集器

它将整个Java堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。G1收集器跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也是Garbage-First名称的由来）。

这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

## 垃圾收集器总结

![](01-Archive/Z-Other/Attachment/image-垃圾回收机制/image_6.png)

## 参考目录

1. [深入理解java垃圾回收机制 - Sunnier - 博客园](https://www.cnblogs.com/sunniest/p/4575144.html)
2. [Java虚拟机5：Java垃圾回收（GC）机制详解 - 五月的仓颉 - 博客园](https://www.cnblogs.com/xrq730/p/4836700.html)